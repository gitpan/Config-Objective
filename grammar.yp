
###
###  Copyright 2002-2003 University of Illinois Board of Trustees
###  Copyright 2002-2003 Mark D. Roth
###  All rights reserved. 
###
###  grammar.yp - Parse::Yapp grammar for Config::Objective
###
###  Mark D. Roth <roth@uiuc.edu>
###  Campus Information Technologies and Educational Services
###  University of Illinois at Urbana-Champaign
###


###
### Header section
###

%{
use strict;
%}


%left AND OR
%right NOT


%%

###
### Rules section
###

config	: #empty
	| config directive 
	;

directive
	: statement
	| conditional
	| include
	;

include	: INCLUDE string
	{
		my ($config) = $_[0]->YYData->{'config'};

		return undef
			if (@{$config->{'cond_stack'}}
			    && $config->{'cond_stack'}->[-1] != 1);

		$_[2] = $config->{'include_dir'} . '/' . $_[2]
			if ($_[2] !~ m|^/|);

		$config->parse($_[2]);
	}
	;

conditional
	: cond_if config cond_endif
	| cond_elif
	| cond_else
	;

expression
	: expr
	| NOT expression
	{
		return (! $_[2]);
	}
	| expression OR expression
	{
		return ($_[1] || $_[3]);
	}
	| expression AND expression
	{
		return ($_[1] && $_[3]);
	}
	| PAREN_START expression PAREN_END
	{
		return $_[2];
	}
	;

expr	:
	{
		my ($config) = $_[0]->YYData->{'config'};
		$config->{'in_expr'} = 1;
	}
	method_call
	{
		my ($config) = $_[0]->YYData->{'config'};
		$config->{'in_expr'} = 0;
		return $_[2];
	}
	;

cond_if	: IF PAREN_START expression PAREN_END
	{
		my ($config) = $_[0]->YYData->{'config'};

		push(@{$config->{'cond_stack'}}, $_[3] ? 1 : 0);
	}
	;

cond_endif
	: ENDIF
	{
		my ($config) = $_[0]->YYData->{'config'};

		die "%endif: not in conditional\n"
			if (! @{$config->{'cond_stack'}});

		pop(@{$config->{'cond_stack'}});
	}
	;

cond_elif
	: ELIF PAREN_START expression PAREN_END
	{
		my ($config) = $_[0]->YYData->{'config'};

		die "%elif: not in conditional\n"
			if (! @{$config->{'cond_stack'}});

		### all previous options were false, so evaluate the
		### specified conditional expression
		if ($config->{'cond_stack'}->[-1] == 0)
		{
			$config->{'cond_stack'}->[-1] = ($_[3] ? 1 : 0);
		}

		### the last option was true, so set to -1
		elsif ($config->{'cond_stack'}->[-1] == 1)
		{
			$config->{'cond_stack'}->[-1] = -1;
		}

		### if it's -1, leave it alone
	}
	;

cond_else
	: ELSE
	{
		my ($config) = $_[0]->YYData->{'config'};

		die '%else: not in conditional'
			if (! @{$config->{'cond_stack'}});

		### all previous options were false, so set to true
		if ($config->{'cond_stack'}->[-1] == 0)
		{
			$config->{'cond_stack'}->[-1] = 1;
		}

		### the last option was true, so set to -1
		elsif ($config->{'cond_stack'}->[-1] == 1)
		{
			$config->{'cond_stack'}->[-1] = -1;
		}

		### if it's -1, leave it alone
	}
	;

string	: WORD
	| QSTRING
	;

value	: string
	| list
	| hash
	;

statement
	: method_call EOS
	;

method_name
	: #empty
	{
		my ($config) = $_[0]->YYData->{'config'};
		return ($config->{'in_expr'} ? 'equals' : 'default');
	}
	| METHOD_ARROW WORD
	{
		return $_[2];
	}
	;

method_args
	: #empty
	{
		return undef;
	}
	| value
	;

method_call
	: WORD method_name method_args
	{
		my ($config) = $_[0]->YYData->{'config'};

#		print "var='$_[1]' method='$_[2]' value='$_[3]'\n";

		### don't bother evaluating if a previous condition was true
		return undef
			if ($config->{'in_expr'}
			    && $config->{'cond_stack'}->[-1] == -1);

		### don't evaluate if we're inside a false conditional block
		return undef
			if (! $config->{'in_expr'}
			    && @{$config->{'cond_stack'}}
			    && $config->{'cond_stack'}->[-1] != 1);

		return $config->_call_obj_method($_[1], $_[2], $_[3]);
	}
	;

list	: LIST_START
	{
		my ($config) = $_[0]->YYData->{'config'};
		push(@{$config->{'list_stack'}}, []);
	}
	list_values LIST_END
	{
		my ($config) = $_[0]->YYData->{'config'};
		return pop(@{$config->{'list_stack'}});
	}
	;

list_values
	: #empty
	| value
	{
		my ($config) = $_[0]->YYData->{'config'};
		push(@{$config->{'list_stack'}->[-1]}, $_[1]);
	}
	| list_values COMMA value
	{
		my ($config) = $_[0]->YYData->{'config'};
		push(@{$config->{'list_stack'}->[-1]}, $_[3]);
	}
	;

hash	: HASH_START HASH_END
	{
		return {};
	}
	| HASH_START
	{
		my ($config) = $_[0]->YYData->{'config'};

		push(@{$config->{'hash_stack'}}, {});
	}
	hash_values HASH_END
	{
		my ($config) = $_[0]->YYData->{'config'};

		return pop(@{$config->{'hash_stack'}});
	}
	;

hash_values
	: hash_values COMMA hash_value
	| hash_value
	;

hash_value
	: string
	{
		my ($config) = $_[0]->YYData->{'config'};

#		print "\t'$_[1]' => undef\n";
		$config->{'hash_stack'}->[-1]->{$_[1]} = undef;
	}
	| string HASH_ARROW value
	{
		my ($config) = $_[0]->YYData->{'config'};

#		print "\t'$_[1]' => '$_[3]'\n";
		$config->{'hash_stack'}->[-1]->{$_[1]} = $_[3];
	}
	;

%%

###
### Footer section
###


